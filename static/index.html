<!DOCTYPE html>
<html>

<head>
    <title>Test Player</title>
</head>

<body>
    <p>An experiment to see if I can sufficiently synchronize the playback of a midi file across multiple clients.</p>

    <button onclick="connect()">
        Connect
    </button>

    <button onclick="disconnect()">
        Disconnect
    </button>

    <p id="delta"></p>

    <script src="https://unpkg.com/jzz"></script>
    <script src="https://unpkg.com/jzz-synth-tiny"></script>
    <script>
        JZZ.synth.Tiny.register('Web Audio');
        var ws = new WebSocket('ws://localhost:8080/ws');

        // Establish a connection to the server
        function connect() {
            var midiAccess = JZZ().openMidiOut('Web Audio');
            var midiEvents = [];

            // delta = clientTime - serverTime
            // so 
            // delta + serverTime = clientTime
            let delta = 0;
            setInterval(() => {
                document.getElementById('delta').innerText = 'Delta: ' + delta;
            }, 1000);

            // Connect to the server
            ws.onopen = function () {
                console.log('Connected');
            };
            ws.onmessage = function (event) {
                event.data.arrayBuffer().then(buffer => {
                    const type = new DataView(buffer, 0).getUint8(0);
                    switch (type) {
                        // TIME SYNC
                        case 0:
                            const serverTime = Number(new DataView(buffer, 1, 8).getFloat64(0));
                            const clientTime = performance.now();
                            delta = clientTime - serverTime;
                            break;
                        // MIDI EVENT(s)
                        case 1:
                            console.log('Midi Event');
                            // Start iteration from the second byte
                            for (let i = 1; i < buffer.byteLength; i += 11) {
                                // Check if there's enough space for absTime and data
                                if (i + 11 <= buffer.byteLength) {
                                    const absTime = new DataView(buffer, i, 8).getFloat64(0);
                                    const data = new Uint8Array(buffer, i + 8, 3);
                                    midiEvents.push({ absTime, data });
                                } else {
                                    // Handle incomplete event data or end of buffer
                                    break;
                                }
                            }
                            break;
                        // Program Changes
                        case 2:
                            // 1-9 - absTime (float64)
                            // 10-11 - midi data
                            const absTime = new DataView(buffer, 1, 8).getFloat64(0);
                            const data = new Uint8Array(buffer, 9, 2);
                            midiEvents.push({ absTime, data });
                            break;
                        // START
                        case 3:
                            // 1-9 - Start time
                            const serverStartTime = new DataView(buffer, 1, 8).getFloat64(0);
                            const startTime = serverStartTime + delta;
                            console.log('Start', 'Server Start Time: ' + serverStartTime, 'Start Time: ' + startTime);
                            // sort midi events by absTime
                            midiEvents.sort((a, b) => a.absTime - b.absTime);

                            // Midi events need to be [number] instead of uint8array
                            midiEvents.forEach(event => {
                                event.data = [...event.data];
                            });

                            playback(startTime);
                            break;
                        // STOP
                        case 4:
                            console.log('Stop');
                            break;
                    }
                });
            };
            ws.onclose = function () {
                console.log('Disconnected');
            };

            // Core playback loop
            async function playback(startTime) {
                const sleep = ms => new Promise(r => setTimeout(r, ms));

                // Sleep until the start time
                await sleep(startTime - performance.now());

                // Start the midi playback
                for (let i = 0; i < midiEvents.length; i++) {
                    const event = midiEvents[i];
                    if (event.absTime < performance.now()) {
                        // Send the midi event
                        midiAccess.send(event.data);
                    } else {
                        // Sleep until the event time 
                        await sleep(event.absTime - performance.now());
                        // Send the midi event
                        midiAccess.send(event.data);
                    }
                }
            }
        }

        // Close the connection to the server
        function disconnect() {
            ws.close();
        }

    </script>

</body>

</html>